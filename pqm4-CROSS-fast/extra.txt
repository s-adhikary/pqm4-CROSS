#include <stdint.h>

static const uint64_t constants[80] = {
  0x428a2f98d728ae22ULL
, 0x7137449123ef65cdULL
, 0xb5c0fbcfec4d3b2fULL
, 0xe9b5dba58189dbbcULL
, 0x3956c25bf348b538ULL
, 0x59f111f1b605d019ULL
, 0x923f82a4af194f9bULL
, 0xab1c5ed5da6d8118ULL
, 0xd807aa98a3030242ULL
, 0x12835b0145706fbeULL
, 0x243185be4ee4b28cULL
, 0x550c7dc3d5ffb4e2ULL
, 0x72be5d74f27b896fULL
, 0x80deb1fe3b1696b1ULL
, 0x9bdc06a725c71235ULL
, 0xc19bf174cf692694ULL
, 0xe49b69c19ef14ad2ULL
, 0xefbe4786384f25e3ULL
, 0x0fc19dc68b8cd5b5ULL
, 0x240ca1cc77ac9c65ULL
, 0x2de92c6f592b0275ULL
, 0x4a7484aa6ea6e483ULL
, 0x5cb0a9dcbd41fbd4ULL
, 0x76f988da831153b5ULL
, 0x983e5152ee66dfabULL
, 0xa831c66d2db43210ULL
, 0xb00327c898fb213fULL
, 0xbf597fc7beef0ee4ULL
, 0xc6e00bf33da88fc2ULL
, 0xd5a79147930aa725ULL
, 0x06ca6351e003826fULL
, 0x142929670a0e6e70ULL
, 0x27b70a8546d22ffcULL
, 0x2e1b21385c26c926ULL
, 0x4d2c6dfc5ac42aedULL
, 0x53380d139d95b3dfULL
, 0x650a73548baf63deULL
, 0x766a0abb3c77b2a8ULL
, 0x81c2c92e47edaee6ULL
, 0x92722c851482353bULL
, 0xa2bfe8a14cf10364ULL
, 0xa81a664bbc423001ULL
, 0xc24b8b70d0f89791ULL
, 0xc76c51a30654be30ULL
, 0xd192e819d6ef5218ULL
, 0xd69906245565a910ULL
, 0xf40e35855771202aULL
, 0x106aa07032bbd1b8ULL
, 0x19a4c116b8d2d0c8ULL
, 0x1e376c085141ab53ULL
, 0x2748774cdf8eeb99ULL
, 0x34b0bcb5e19b48a8ULL
, 0x391c0cb3c5c95a63ULL
, 0x4ed8aa4ae3418acbULL
, 0x5b9cca4f7763e373ULL
, 0x682e6ff3d6b2b8a3ULL
, 0x748f82ee5defb2fcULL
, 0x78a5636f43172f60ULL
, 0x84c87814a1f0ab72ULL
, 0x8cc702081a6439ecULL
, 0x90befffa23631e28ULL
, 0xa4506cebde82bde9ULL
, 0xbef9a3f7b2c67915ULL
, 0xc67178f2e372532bULL
, 0xca273eceea26619cULL
, 0xd186b8c721c0c207ULL
, 0xeada7dd6cde0eb1eULL
, 0xf57d4f7fee6ed178ULL
, 0x06f067aa72176fbaULL
, 0x0a637dc5a2c898a6ULL
, 0x113f9804bef90daeULL
, 0x1b710b35131c471bULL
, 0x28db77f523047d84ULL
, 0x32caab7b40c72493ULL
, 0x3c9ebe0a15c9bebcULL
, 0x431d67c49c100d4cULL
, 0x4cc5d4becb3e42b6ULL
, 0x597f299cfc657e2aULL
, 0x5fcb6fab3ad6faecULL
, 0x6c44198c4a475817ULL
};

#if defined CRYPTO_HASHBLOCKS_SHA512_H
//#define CRYPTO_HASHBLOCKS_SHA512_H
#define CUTOFF 32768 /* must be multiple of 128 */

extern int crypto_hashblocks_sha512_m4nofpu_inner(unsigned char *,const unsigned char *,unsigned int,const uint64_t *);

int crypto_hashblocks_sha512_new1(unsigned char *statebytes,const unsigned char *in,unsigned long long inlen)
{
  while (inlen >= CUTOFF) {
    crypto_hashblocks_sha512_m4nofpu_inner(statebytes,in,CUTOFF,constants); /* returns 0 */
    in += CUTOFF;
    inlen -= CUTOFF;
  }
  if (inlen < 128) return inlen;
  return crypto_hashblocks_sha512_m4nofpu_inner(statebytes,in,inlen,constants);
  
}
#else
static size_t crypto_hashblocks_sha512_old(uint8_t *statebytes,
                                       const uint8_t *in, size_t inlen) {
    uint64_t state[8];
    uint64_t a;
    uint64_t b;
    uint64_t c;
    uint64_t d;
    uint64_t e;
    uint64_t f;
    uint64_t g;
    uint64_t h;
    uint64_t T1;
    uint64_t T2;

    a = load_bigendian_64(statebytes + 0);
    state[0] = a;
    b = load_bigendian_64(statebytes + 8);
    state[1] = b;
    c = load_bigendian_64(statebytes + 16);
    state[2] = c;
    d = load_bigendian_64(statebytes + 24);
    state[3] = d;
    e = load_bigendian_64(statebytes + 32);
    state[4] = e;
    f = load_bigendian_64(statebytes + 40);
    state[5] = f;
    g = load_bigendian_64(statebytes + 48);
    state[6] = g;
    h = load_bigendian_64(statebytes + 56);
    state[7] = h;

    while (inlen >= 128) {
        uint64_t w0 = load_bigendian_64(in + 0);
        uint64_t w1 = load_bigendian_64(in + 8);
        uint64_t w2 = load_bigendian_64(in + 16);
        uint64_t w3 = load_bigendian_64(in + 24);
        uint64_t w4 = load_bigendian_64(in + 32);
        uint64_t w5 = load_bigendian_64(in + 40);
        uint64_t w6 = load_bigendian_64(in + 48);
        uint64_t w7 = load_bigendian_64(in + 56);
        uint64_t w8 = load_bigendian_64(in + 64);
        uint64_t w9 = load_bigendian_64(in + 72);
        uint64_t w10 = load_bigendian_64(in + 80);
        uint64_t w11 = load_bigendian_64(in + 88);
        uint64_t w12 = load_bigendian_64(in + 96);
        uint64_t w13 = load_bigendian_64(in + 104);
        uint64_t w14 = load_bigendian_64(in + 112);
        uint64_t w15 = load_bigendian_64(in + 120);

        F_64(w0, 0x428a2f98d728ae22ULL)
        F_64(w1, 0x7137449123ef65cdULL)
        F_64(w2, 0xb5c0fbcfec4d3b2fULL)
        F_64(w3, 0xe9b5dba58189dbbcULL)
        F_64(w4, 0x3956c25bf348b538ULL)
        F_64(w5, 0x59f111f1b605d019ULL)
        F_64(w6, 0x923f82a4af194f9bULL)
        F_64(w7, 0xab1c5ed5da6d8118ULL)
        F_64(w8, 0xd807aa98a3030242ULL)
        F_64(w9, 0x12835b0145706fbeULL)
        F_64(w10, 0x243185be4ee4b28cULL)
        F_64(w11, 0x550c7dc3d5ffb4e2ULL)
        F_64(w12, 0x72be5d74f27b896fULL)
        F_64(w13, 0x80deb1fe3b1696b1ULL)
        F_64(w14, 0x9bdc06a725c71235ULL)
        F_64(w15, 0xc19bf174cf692694ULL)

        EXPAND_64

        F_64(w0, 0xe49b69c19ef14ad2ULL)
        F_64(w1, 0xefbe4786384f25e3ULL)
        F_64(w2, 0x0fc19dc68b8cd5b5ULL)
        F_64(w3, 0x240ca1cc77ac9c65ULL)
        F_64(w4, 0x2de92c6f592b0275ULL)
        F_64(w5, 0x4a7484aa6ea6e483ULL)
        F_64(w6, 0x5cb0a9dcbd41fbd4ULL)
        F_64(w7, 0x76f988da831153b5ULL)
        F_64(w8, 0x983e5152ee66dfabULL)
        F_64(w9, 0xa831c66d2db43210ULL)
        F_64(w10, 0xb00327c898fb213fULL)
        F_64(w11, 0xbf597fc7beef0ee4ULL)
        F_64(w12, 0xc6e00bf33da88fc2ULL)
        F_64(w13, 0xd5a79147930aa725ULL)
        F_64(w14, 0x06ca6351e003826fULL)
        F_64(w15, 0x142929670a0e6e70ULL)

        EXPAND_64

        F_64(w0, 0x27b70a8546d22ffcULL)
        F_64(w1, 0x2e1b21385c26c926ULL)
        F_64(w2, 0x4d2c6dfc5ac42aedULL)
        F_64(w3, 0x53380d139d95b3dfULL)
        F_64(w4, 0x650a73548baf63deULL)
        F_64(w5, 0x766a0abb3c77b2a8ULL)
        F_64(w6, 0x81c2c92e47edaee6ULL)
        F_64(w7, 0x92722c851482353bULL)
        F_64(w8, 0xa2bfe8a14cf10364ULL)
        F_64(w9, 0xa81a664bbc423001ULL)
        F_64(w10, 0xc24b8b70d0f89791ULL)
        F_64(w11, 0xc76c51a30654be30ULL)
        F_64(w12, 0xd192e819d6ef5218ULL)
        F_64(w13, 0xd69906245565a910ULL)
        F_64(w14, 0xf40e35855771202aULL)
        F_64(w15, 0x106aa07032bbd1b8ULL)

        EXPAND_64

        F_64(w0, 0x19a4c116b8d2d0c8ULL)
        F_64(w1, 0x1e376c085141ab53ULL)
        F_64(w2, 0x2748774cdf8eeb99ULL)
        F_64(w3, 0x34b0bcb5e19b48a8ULL)
        F_64(w4, 0x391c0cb3c5c95a63ULL)
        F_64(w5, 0x4ed8aa4ae3418acbULL)
        F_64(w6, 0x5b9cca4f7763e373ULL)
        F_64(w7, 0x682e6ff3d6b2b8a3ULL)
        F_64(w8, 0x748f82ee5defb2fcULL)
        F_64(w9, 0x78a5636f43172f60ULL)
        F_64(w10, 0x84c87814a1f0ab72ULL)
        F_64(w11, 0x8cc702081a6439ecULL)
        F_64(w12, 0x90befffa23631e28ULL)
        F_64(w13, 0xa4506cebde82bde9ULL)
        F_64(w14, 0xbef9a3f7b2c67915ULL)
        F_64(w15, 0xc67178f2e372532bULL)

        EXPAND_64

        F_64(w0, 0xca273eceea26619cULL)
        F_64(w1, 0xd186b8c721c0c207ULL)
        F_64(w2, 0xeada7dd6cde0eb1eULL)
        F_64(w3, 0xf57d4f7fee6ed178ULL)
        F_64(w4, 0x06f067aa72176fbaULL)
        F_64(w5, 0x0a637dc5a2c898a6ULL)
        F_64(w6, 0x113f9804bef90daeULL)
        F_64(w7, 0x1b710b35131c471bULL)
        F_64(w8, 0x28db77f523047d84ULL)
        F_64(w9, 0x32caab7b40c72493ULL)
        F_64(w10, 0x3c9ebe0a15c9bebcULL)
        F_64(w11, 0x431d67c49c100d4cULL)
        F_64(w12, 0x4cc5d4becb3e42b6ULL)
        F_64(w13, 0x597f299cfc657e2aULL)
        F_64(w14, 0x5fcb6fab3ad6faecULL)
        F_64(w15, 0x6c44198c4a475817ULL)

        a += state[0];
        b += state[1];
        c += state[2];
        d += state[3];
        e += state[4];
        f += state[5];
        g += state[6];
        h += state[7];

        state[0] = a;
        state[1] = b;
        state[2] = c;
        state[3] = d;
        state[4] = e;
        state[5] = f;
        state[6] = g;
        state[7] = h;

        in += 128;
        inlen -= 128;
    }

    store_bigendian_64(statebytes + 0, state[0]);
    store_bigendian_64(statebytes + 8, state[1]);
    store_bigendian_64(statebytes + 16, state[2]);
    store_bigendian_64(statebytes + 24, state[3]);
    store_bigendian_64(statebytes + 32, state[4]);
    store_bigendian_64(statebytes + 40, state[5]);
    store_bigendian_64(statebytes + 48, state[6]);
    store_bigendian_64(statebytes + 56, state[7]);

    return inlen;
}

#endif

static size_t crypto_hashblocks_sha512_new(uint8_t *statebytes,
                                       const uint8_t *in, size_t inlen, uint8_t *buf, uint32_t *state, int t) {
    //uint64_t state[8];
    uint64_t a;
    uint64_t b;
    uint64_t c;
    uint64_t d;
    uint64_t e;
    uint64_t f;
    uint64_t g;
    uint64_t h;
    uint64_t T1;
    uint64_t T2;

    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    f = state[5];
    g = state[6];
    h = state[7];

    while (inlen >= 128) {
        uint64_t w0 = load_bigendian_64(in + 0);
        uint64_t w1 = load_bigendian_64(in + 8);
        uint64_t w2 = load_bigendian_64(in + 16);
        uint64_t w3 = load_bigendian_64(in + 24);
        uint64_t w4 = load_bigendian_64(in + 32);
        uint64_t w5 = load_bigendian_64(in + 40);
        uint64_t w6 = load_bigendian_64(in + 48);
        uint64_t w7 = load_bigendian_64(in + 56);
        uint64_t w8 = load_bigendian_64(in + 64);
        uint64_t w9 = load_bigendian_64(in + 72);
        uint64_t w10 = load_bigendian_64(in + 80);
        uint64_t w11 = load_bigendian_64(in + 88);
        uint64_t w12 = load_bigendian_64(in + 96);
        uint64_t w13 = load_bigendian_64(in + 104);
        uint64_t w14 = load_bigendian_64(in + 112);
        uint64_t w15 = load_bigendian_64(in + 120);

        F_64(w0, 0x428a2f98d728ae22ULL)
        F_64(w1, 0x7137449123ef65cdULL)
        F_64(w2, 0xb5c0fbcfec4d3b2fULL)
        F_64(w3, 0xe9b5dba58189dbbcULL)
        F_64(w4, 0x3956c25bf348b538ULL)
        F_64(w5, 0x59f111f1b605d019ULL)
        F_64(w6, 0x923f82a4af194f9bULL)
        F_64(w7, 0xab1c5ed5da6d8118ULL)
        F_64(w8, 0xd807aa98a3030242ULL)
        F_64(w9, 0x12835b0145706fbeULL)
        F_64(w10, 0x243185be4ee4b28cULL)
        F_64(w11, 0x550c7dc3d5ffb4e2ULL)
        F_64(w12, 0x72be5d74f27b896fULL)
        F_64(w13, 0x80deb1fe3b1696b1ULL)
        F_64(w14, 0x9bdc06a725c71235ULL)
        F_64(w15, 0xc19bf174cf692694ULL)

        EXPAND_64

        F_64(w0, 0xe49b69c19ef14ad2ULL)
        F_64(w1, 0xefbe4786384f25e3ULL)
        F_64(w2, 0x0fc19dc68b8cd5b5ULL)
        F_64(w3, 0x240ca1cc77ac9c65ULL)
        F_64(w4, 0x2de92c6f592b0275ULL)
        F_64(w5, 0x4a7484aa6ea6e483ULL)
        F_64(w6, 0x5cb0a9dcbd41fbd4ULL)
        F_64(w7, 0x76f988da831153b5ULL)
        F_64(w8, 0x983e5152ee66dfabULL)
        F_64(w9, 0xa831c66d2db43210ULL)
        F_64(w10, 0xb00327c898fb213fULL)
        F_64(w11, 0xbf597fc7beef0ee4ULL)
        F_64(w12, 0xc6e00bf33da88fc2ULL)
        F_64(w13, 0xd5a79147930aa725ULL)
        F_64(w14, 0x06ca6351e003826fULL)
        F_64(w15, 0x142929670a0e6e70ULL)

        EXPAND_64

        F_64(w0, 0x27b70a8546d22ffcULL)
        F_64(w1, 0x2e1b21385c26c926ULL)
        F_64(w2, 0x4d2c6dfc5ac42aedULL)
        F_64(w3, 0x53380d139d95b3dfULL)
        F_64(w4, 0x650a73548baf63deULL)
        F_64(w5, 0x766a0abb3c77b2a8ULL)
        F_64(w6, 0x81c2c92e47edaee6ULL)
        F_64(w7, 0x92722c851482353bULL)
        F_64(w8, 0xa2bfe8a14cf10364ULL)
        F_64(w9, 0xa81a664bbc423001ULL)
        F_64(w10, 0xc24b8b70d0f89791ULL)
        F_64(w11, 0xc76c51a30654be30ULL)
        F_64(w12, 0xd192e819d6ef5218ULL)
        F_64(w13, 0xd69906245565a910ULL)
        F_64(w14, 0xf40e35855771202aULL)
        F_64(w15, 0x106aa07032bbd1b8ULL)

        EXPAND_64

        F_64(w0, 0x19a4c116b8d2d0c8ULL)
        F_64(w1, 0x1e376c085141ab53ULL)
        F_64(w2, 0x2748774cdf8eeb99ULL)
        F_64(w3, 0x34b0bcb5e19b48a8ULL)
        F_64(w4, 0x391c0cb3c5c95a63ULL)
        F_64(w5, 0x4ed8aa4ae3418acbULL)
        F_64(w6, 0x5b9cca4f7763e373ULL)
        F_64(w7, 0x682e6ff3d6b2b8a3ULL)
        F_64(w8, 0x748f82ee5defb2fcULL)
        F_64(w9, 0x78a5636f43172f60ULL)
        F_64(w10, 0x84c87814a1f0ab72ULL)
        F_64(w11, 0x8cc702081a6439ecULL)
        F_64(w12, 0x90befffa23631e28ULL)
        F_64(w13, 0xa4506cebde82bde9ULL)
        F_64(w14, 0xbef9a3f7b2c67915ULL)
        F_64(w15, 0xc67178f2e372532bULL)

        EXPAND_64

        F_64(w0, 0xca273eceea26619cULL)
        F_64(w1, 0xd186b8c721c0c207ULL)
        F_64(w2, 0xeada7dd6cde0eb1eULL)
        F_64(w3, 0xf57d4f7fee6ed178ULL)
        F_64(w4, 0x06f067aa72176fbaULL)
        F_64(w5, 0x0a637dc5a2c898a6ULL)
        F_64(w6, 0x113f9804bef90daeULL)
        F_64(w7, 0x1b710b35131c471bULL)
        F_64(w8, 0x28db77f523047d84ULL)
        F_64(w9, 0x32caab7b40c72493ULL)
        F_64(w10, 0x3c9ebe0a15c9bebcULL)
        F_64(w11, 0x431d67c49c100d4cULL)
        F_64(w12, 0x4cc5d4becb3e42b6ULL)
        F_64(w13, 0x597f299cfc657e2aULL)
        F_64(w14, 0x5fcb6fab3ad6faecULL)
        F_64(w15, 0x6c44198c4a475817ULL)

        a += state[0];
        b += state[1];
        c += state[2];
        d += state[3];
        e += state[4];
        f += state[5];
        g += state[6];
        h += state[7];

        state[0] = a;
        state[1] = b;
        state[2] = c;
        state[3] = d;
        state[4] = e;
        state[5] = f;
        state[6] = g;
        state[7] = h;

        in += 128;
        inlen -= 128;
    }
     if(t==0){
        memcpy(buf, in, inlen);
    }
    else{
        store_bigendian_64(statebytes + 0, state[0]);
        store_bigendian_64(statebytes + 8, state[1]);
        store_bigendian_64(statebytes + 16, state[2]);
        store_bigendian_64(statebytes + 24, state[3]);
        store_bigendian_64(statebytes + 32, state[4]);
        store_bigendian_64(statebytes + 40, state[5]);
        store_bigendian_64(statebytes + 48, state[6]);
        store_bigendian_64(statebytes + 56, state[7]);
    }
    return inlen;
}

void sha512_inc_finalize_new(uint8_t *out, sha512ctx *state, const uint8_t *in, size_t inlen, uint64_t bytes, int offset) {
/*#ifdef PROFILE_HASHING
    uint64_t t0 = hal_get_time();
#endif*/

    uint8_t padded[256];

    //uint64_t bytes = load_bigendian_64(state->ctx + 64) + inlen;
    //uint8_t *m_new = in;
    #if defined(CRYPTO_HASHBLOCKS_SHA512_H)
        //crypto_hashblocks_sha512_new2(state->ctx, in, inlen, m_new, 1); 
        crypto_hashblocks_sha512_new1(state->ctx, in, inlen);   
    #else
       /* uint64_t state1[8];
        state1[0] = load_bigendian_64(state->ctx + 0);
        state1[1] = load_bigendian_64(state->ctx + 8);
        state1[2] = load_bigendian_64(state->ctx + 16);
        state1[3] = load_bigendian_64(state->ctx + 24);
        state1[4] = load_bigendian_64(state->ctx + 32);
        state1[5] = load_bigendian_64(state->ctx + 40);
        state1[6] = load_bigendian_64(state->ctx + 48);
        state1[7] = load_bigendian_64(state->ctx + 56);*/

    //hash512_new_init(state1, state);
    crypto_hashblocks_sha512_old(state->ctx, in, inlen);
    //crypto_hashblocks_sha512_new1(state->ctx, in, inlen);
    
        //crypto_hashblocks_sha512_new(state->ctx, in, inlen, m_new, state1, 1);
    #endif
    if(offset == 1){
        in += inlen;
        inlen &= 127;
        in -= inlen;

        for (size_t i = 0; i < inlen; ++i) {
            padded[i] = in[i];
        }
        padded[inlen] = 0x80;

        if (inlen < 112) {
            for (size_t i = inlen + 1; i < 119; ++i) {
                padded[i] = 0;
            }
            padded[119] = (uint8_t) (bytes >> 61);
            padded[120] = (uint8_t) (bytes >> 53);
            padded[121] = (uint8_t) (bytes >> 45);
            padded[122] = (uint8_t) (bytes >> 37);
            padded[123] = (uint8_t) (bytes >> 29);
            padded[124] = (uint8_t) (bytes >> 21);
            padded[125] = (uint8_t) (bytes >> 13);
            padded[126] = (uint8_t) (bytes >> 5);
            padded[127] = (uint8_t) (bytes << 3);

           //m_new = padded;
            /*state1[0] = load_bigendian_64(state->ctx + 0);
            state1[1] = load_bigendian_64(state->ctx + 8);
            state1[2] = load_bigendian_64(state->ctx + 16);
            state1[3] = load_bigendian_64(state->ctx + 24);
            state1[4] = load_bigendian_64(state->ctx + 32);
            state1[5] = load_bigendian_64(state->ctx + 40);
            state1[6] = load_bigendian_64(state->ctx + 48);
            state1[7] = load_bigendian_64(state->ctx + 56);*/
        
            //hash512_new_init(state1, state);    
            //crypto_hashblocks_sha512_new(state->ctx, padded, 128, m_new, state1, 1);
           #if defined (CRYPTO_HASHBLOCKS_SHA512_H)
           crypto_hashblocks_sha512_new1(state->ctx, padded, 128);
           #else
           crypto_hashblocks_sha512_old(state->ctx, padded, 128);
           #endif
           //crypto_hashblocks_sha512(state->ctx, padded, 128);
            //crypto_hashblocks_sha512_new1(state->ctx, padded, 128);
            //crypto_hashblocks_sha512_new2(state->ctx, in, inlen, m_new, 1);
        } else {
            for (size_t i = inlen + 1; i < 247; ++i) {
                padded[i] = 0;
            }
            padded[247] = (uint8_t) (bytes >> 61);
            padded[248] = (uint8_t) (bytes >> 53);
            padded[249] = (uint8_t) (bytes >> 45);
            padded[250] = (uint8_t) (bytes >> 37);
            padded[251] = (uint8_t) (bytes >> 29);
            padded[252] = (uint8_t) (bytes >> 21);
            padded[253] = (uint8_t) (bytes >> 13);
            padded[254] = (uint8_t) (bytes >> 5);
            padded[255] = (uint8_t) (bytes << 3);

            //m_new = padded;
            /*state1[0] = load_bigendian_64(state->ctx + 0);
            state1[1] = load_bigendian_64(state->ctx + 8);
            state1[2] = load_bigendian_64(state->ctx + 16);
            state1[3] = load_bigendian_64(state->ctx + 24);
            state1[4] = load_bigendian_64(state->ctx + 32);
            state1[5] = load_bigendian_64(state->ctx + 40);
            state1[6] = load_bigendian_64(state->ctx + 48);
            state1[7] = load_bigendian_64(state->ctx + 56);*/
            
            //hash512_new_init(state1, state);
            //crypto_hashblocks_sha512_new(state->ctx, padded, 256, m_new, state1, 1);
            #if defined (CRYPTO_HASHBLOCKS_SHA512_H)
           crypto_hashblocks_sha512_new1(state->ctx, padded, 256);
           #else
           crypto_hashblocks_sha512_old(state->ctx, padded, 256);
           #endif
            //crypto_hashblocks_sha512(state->ctx, padded, 256);
            //crypto_hashblocks_sha512_new1(state->ctx, padded, 128);
            //crypto_hashblocks_sha512_new2(state->ctx, in, inlen, m_new, 1);
        }

        for (size_t i = 0; i < 64; ++i) {
            out[i] = state->ctx[i];
        }
    }
/*#ifdef PROFILE_HASHING
    uint64_t t1 = hal_get_time();
    hash_cycles += (t1-t0);
#endif*/
}
void sha384_inc_finalize_new(uint8_t *out, sha384ctx *state, const uint8_t *in, size_t inlen, uint64_t bytes, int offset) {
    sha512_inc_finalize_new(state->ctx, (sha512ctx*)state, in, inlen, bytes, offset);
    for (size_t i = 0; i < 48; ++i) {
        out[i] = state->ctx[i];
    }
}
/Version 11----> Replace all hash function by hash_new for SHA2_HASH condition
void CROSS_sign_v12(const prikey_t *SK,
               const char *const m,
               const uint64_t mlen,
               sig_t *sig){
    /* Key material expansion */
    FQ_ELEM V_tr[N-K][K];
    FZ_ELEM eta[N];
#if defined(RSDP)
    expand_private_seed(eta,V_tr,SK->seed);
#elif defined(RSDPG)
    FZ_ELEM zeta[M];
    FZ_ELEM W_tr[N-M][M];
    expand_private_seed(eta,zeta,V_tr,W_tr,SK->seed);
#endif

    uint8_t root_seed[SEED_LENGTH_BYTES];
    randombytes(root_seed,SEED_LENGTH_BYTES);
    randombytes(sig->salt,SALT_LENGTH_BYTES);

    uint8_t seed_tree[SEED_LENGTH_BYTES*NUM_NODES_OF_SEED_TREE];
    generate_seed_tree_from_root(seed_tree,root_seed,sig->salt);
    uint8_t * seed_tree_leaves = seed_tree +
                                 SEED_LENGTH_BYTES*(NUM_LEAVES_OF_SEED_TREE-1);

    FZ_ELEM eta_tilde[T][N];
    //FZ_ELEM sigma[T][N];
    FZ_ELEM sigma_new[N];
    FQ_ELEM u_tilde[T][N];
    FQ_ELEM s_tilde[N-K];

#if defined(RSDP)
    uint8_t cmt_0_i_input[sizeof(FQ_ELEM)*(N-K)+
                          sizeof(FZ_ELEM)*N+
                          SALT_LENGTH_BYTES+sizeof(uint16_t)];
    const int offset_salt = sizeof(FQ_ELEM)*(N-K)+sizeof(FZ_ELEM)*N;
    const int offset_round_idx = sizeof(FQ_ELEM)*(N-K)+sizeof(FZ_ELEM)*N+SALT_LENGTH_BYTES;
#elif defined(RSDPG)
    FZ_ELEM zeta_tilde[M];
    FZ_ELEM delta[T][M];
    uint8_t cmt_0_i_input[sizeof(FQ_ELEM)*(N-K)+
                          sizeof(FZ_ELEM)*M+
                          SALT_LENGTH_BYTES+sizeof(uint16_t)];
    const int offset_salt = sizeof(FQ_ELEM)*(N-K)+sizeof(FZ_ELEM)*M;
    const int offset_round_idx = sizeof(FQ_ELEM)*(N-K)+sizeof(FZ_ELEM)*M+SALT_LENGTH_BYTES;
#endif

    uint8_t cmt_1_i_input[SEED_LENGTH_BYTES+
                          SALT_LENGTH_BYTES+sizeof(uint16_t)];

    /* cmt_0_i_input is syndrome||sigma ||salt ; place salt at the end */
    memcpy(cmt_0_i_input+offset_salt, sig->salt, SALT_LENGTH_BYTES);
    /* cmt_1_i_input is seed[i]||salt */
    memcpy(cmt_1_i_input+SEED_LENGTH_BYTES, sig->salt, SALT_LENGTH_BYTES);

    // Added this lines (variables) for new hash functions
    size_t i_new;
    #if defined (SHA3_HASH)
        uint64_t s[25], s1[25];
        uint64_t dlen = 0, dlen1=0 ;
        #if (HASH_DIGEST_LENGTH*8 == 256)
            uint8_t r =SHA3_256_RATE;
        #elif (HASH_DIGEST_LENGTH*8 == 384)
            uint8_t r =SHA3_384_RATE;
        #elif (HASH_DIGEST_LENGTH*8 == 512)
            uint8_t r =SHA3_512_RATE;
        #else
            #error digest length unsupported by SHA-3
        #endif
        uint8_t cmt_1_new[r+HASH_DIGEST_LENGTH];
        for (i_new = 0; i_new < 25; ++i_new) {
            s[i_new] = 0;
            s1[i_new] = 0;
        }
        for(i_new=0; i_new<r+HASH_DIGEST_LENGTH; i_new++){
            cmt_1_new[i_new] = 0;
        }
        uint8_t *m_new=cmt_1_i_input;
    #elif defined (SHA2_HASH)
        #if (HASH_DIGEST_LENGTH*8 == 256)
            sha256ctx state;
            uint64_t bytes;
            #ifdef PROFILE_HASHING
                uint64_t t0, t1;
            #endif
            //sha256(digest,m, mlen);
        #elif (HASH_DIGEST_LENGTH*8 == 384)
            sha384ctx state;
            uint64_t bytes;
            #ifdef PROFILE_HASHING
                uint64_t t0, t1;
            #endif
            //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #elif (HASH_DIGEST_LENGTH*8 == 512)
            sha512ctx state;
            uint64_t bytes;
            #ifdef PROFILE_HASHING
                uint64_t t0, t1;
            #endif
        #else
            #error digest length unsupported by SHA-2
        #endif
        uint8_t cmt_1[T][HASH_DIGEST_LENGTH] = {0};    
        //uint8_t *m_new1 = cmt_0_i_input;
    #endif

    //size_t i_new;
    //uint64_t s[25];
    //uint64_t dlen = 0;
    //uint8_t cmt_0[T][HASH_DIGEST_LENGTH] = {0};
    uint8_t cmt_0_new[HASH_DIGEST_LENGTH]={0};
    //uint8_t cmt_1[T][HASH_DIGEST_LENGTH] = {0};
   // uint8_t cmt_1_new[T][HASH_DIGEST_LENGTH] = {0};

    //for (i_new = 0; i_new < 25; ++i_new) {
      //  s[i_new] = 0;
    //}
    //uint8_t *m_new=cmt_1_i_input;
    // New variables those use to make new merkle tree
    unsigned int node_ctr, parent_layer;
    uint8_t merkle_tree_0_new[NUM_NODES_OF_MERKLE_TREE * HASH_DIGEST_LENGTH];
    //uint8_t merkle_tree_0[NUM_NODES_OF_MERKLE_TREE * HASH_DIGEST_LENGTH];
    uint16_t merkle_leaf_indices[T];
    uint16_t layer_offsets[LOGT+1];
    uint16_t nodes_per_layer[LOGT+1];
    setup_tree(layer_offsets, nodes_per_layer);
    get_leaf_indices(merkle_leaf_indices, layer_offsets);
    
    CSPRNG_STATE_T CSPRNG_state;
    uint8_t commit_digests[2][HASH_DIGEST_LENGTH];
    for(int i = 0; i<T; i++){
        uint8_t seed_u_t_seed_e_t[2*SEED_LENGTH_BYTES];
        /* expand seed[i] into seed_e and seed_u */
        initialize_csprng(&CSPRNG_state,
                          seed_tree_leaves+SEED_LENGTH_BYTES*i,
                          SEED_LENGTH_BYTES);
        csprng_randombytes(seed_u_t_seed_e_t,
                           2*SEED_LENGTH_BYTES,
                           &CSPRNG_state);

        /* expand eta_tilde */
#if defined(RSDP)
        initialize_csprng(&CSPRNG_state,
                          seed_u_t_seed_e_t+SEED_LENGTH_BYTES,
                          SEED_LENGTH_BYTES);
        CSPRNG_zz_vec(eta_tilde[i], &CSPRNG_state);
#elif defined(RSDPG)
        initialize_csprng(&CSPRNG_state,
                          seed_u_t_seed_e_t+SEED_LENGTH_BYTES,
                          SEED_LENGTH_BYTES);
        CSPRNG_zz_inf_w(zeta_tilde, &CSPRNG_state);
        restr_inf_w_sub(delta[i], zeta,zeta_tilde);
        fz_dz_norm_delta(delta[i]);

        fz_inf_w_by_fz_matrix(eta_tilde[i],zeta_tilde,W_tr);
        fz_dz_norm_sigma(eta_tilde[i]);
#endif
       // restr_vec_sub(sigma[i], eta,eta_tilde[i]);
         restr_vec_sub(sigma_new, eta,eta_tilde[i]);
        FQ_ELEM v[N];
        //convert_restr_vec_to_fq(v,sigma[i]);
        convert_restr_vec_to_fq(v,sigma_new);
        //fz_dz_norm_sigma(sigma[i]);
        fz_dz_norm_sigma(sigma_new);
        /* expand u_tilde */
        initialize_csprng(&CSPRNG_state,
                          seed_u_t_seed_e_t,
                          SEED_LENGTH_BYTES);
        CSPRNG_fq_vec(u_tilde[i], &CSPRNG_state);

        FQ_ELEM u[N];
        fq_vec_by_fq_vec_pointwise(u,v,u_tilde[i]);
        fq_vec_by_fq_matrix(s_tilde,u,V_tr);
        fq_dz_norm_synd(s_tilde);

        /* container for s-tilde, sigma_i and salt */
        memcpy(cmt_0_i_input, s_tilde, sizeof(FQ_ELEM)*(N-K));
        const int offset_sigma_delta = sizeof(FQ_ELEM)*(N-K);

#if defined(RSDP)
        //memcpy(cmt_0_i_input + offset_sigma_delta, sigma[i], sizeof(FZ_ELEM)*N);
        memcpy(cmt_0_i_input + offset_sigma_delta, sigma_new, sizeof(FZ_ELEM)*N);
#elif defined(RSDPG)
        memcpy(cmt_0_i_input + offset_sigma_delta, delta[i], sizeof(FZ_ELEM)*M);
#endif
        /* Fixed endianness marshalling of round counter */
        cmt_0_i_input[offset_round_idx] = (i >> 8) &0xFF;
        cmt_0_i_input[offset_round_idx+1] = i & 0xFF;
        
        //hash(cmt_0_new,cmt_0_i_input,sizeof(cmt_0_i_input));
        // hash_new(uint8_t* sig_new_digest_b, uint64_t* s, uint8_t* digest_b_buf_new, uint64_t* dlen, 
//uint8_t* m_new, uint8_t r, int offset 
//)
        #if defined (SHA3_HASH)
            m_new = cmt_0_i_input;
            dlen = sizeof(cmt_0_i_input);
            hash_new(cmt_0_new, s, cmt_0_i_input, &dlen, m_new, r, 1);
            for (i_new = 0; i_new < 25; ++i_new) {
                s[i_new] = 0;
            }
        #elif defined (SHA2_HASH)
            #if (HASH_DIGEST_LENGTH*8 == 256)
                //sha256ctx state;
                sha256_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 32) + sizeof(cmt_0_i_input);
                sha256_inc_finalize_new(cmt_0_new, &state, cmt_0_i_input, sizeof(cmt_0_i_input), bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                //sha256(digest,m, mlen);
            #elif (HASH_DIGEST_LENGTH*8 == 384)
               // sha384ctx state;
                sha384_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 64) + sizeof(cmt_0_i_input);
                sha384_inc_finalize_new(cmt_0_new, &state, cmt_0_i_input, sizeof(cmt_0_i_input), bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                for (i_new = 0; i_new < 48; ++i_new) {
                    cmt_0_new[i_new] = state.ctx[i_new];
                }
                //sha384_inc_finalize(cmt_0_new, &state, cmt_0_i_input, sizeof(cmt_0_i_input));
                //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
            #elif (HASH_DIGEST_LENGTH*8 == 512)
               // sha512ctx state;
                sha512_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 64) + sizeof(cmt_0_i_input);
                sha512_inc_finalize_new(cmt_0_new, &state, cmt_0_i_input, sizeof(cmt_0_i_input), bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                //sha512_inc_finalize(cmt_0_new, &state, cmt_0_i_input, sizeof(cmt_0_i_input));
                
                //sha512(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
            #else
            #error digest length unsupported by SHA-2
            #endif
            //hash(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #endif

        memcpy(merkle_tree_0_new + merkle_leaf_indices[i]*HASH_DIGEST_LENGTH, 
                cmt_0_new,
                HASH_DIGEST_LENGTH);
        
        memcpy(cmt_1_i_input,
               seed_tree_leaves+SEED_LENGTH_BYTES*i,
               SEED_LENGTH_BYTES);
        cmt_1_i_input[SEED_LENGTH_BYTES+SALT_LENGTH_BYTES] = (i >> 8) &0xFF;
        cmt_1_i_input[SEED_LENGTH_BYTES+SALT_LENGTH_BYTES+1] = i & 0xFF;        
        //hash(cmt_1[i],cmt_1_i_input,sizeof(cmt_1_i_input));
        #if defined (SHA3_HASH)
            m_new = cmt_1_i_input;
            dlen = sizeof(cmt_1_i_input);
            hash_new(cmt_1_new+dlen1, s, cmt_1_i_input, &dlen, m_new, r, 1);
            for (i_new = 0; i_new < 25; ++i_new) {
                s[i_new] = 0;
            }    
            dlen1 += HASH_DIGEST_LENGTH;
            if(dlen1>r && i!=T-1){
                m_new = cmt_1_new;
                hash_new(commit_digests[1], s1, cmt_1_new, &dlen1, m_new, r, 0);
            }
            if(i==T-1){
                m_new = cmt_1_new;
                hash_new(commit_digests[1], s1, cmt_1_new, &dlen1, m_new, r, 1);
            }
        #elif defined (SHA2_HASH)
            #if (HASH_DIGEST_LENGTH*8 == 256)
                //sha256ctx state;
                sha256_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 32) + sizeof(cmt_1_i_input);
                sha256_inc_finalize_new(cmt_1[i], &state, cmt_1_i_input, sizeof(cmt_1_i_input), bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                //sha256_inc_finalize(cmt_1[i], &state, cmt_1_i_input, sizeof(cmt_1_i_input));
                //sha256(digest,m, mlen);
            #elif (HASH_DIGEST_LENGTH*8 == 384)
               // sha384ctx state;
                sha384_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 32) + sizeof(cmt_1_i_input);
                sha384_inc_finalize_new(cmt_1[i], &state, cmt_1_i_input, sizeof(cmt_1_i_input), bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                for (i_new = 0; i_new < 48; ++i_new) {
                    cmt_1[i][i_new] = state.ctx[i_new];
                }
                //sha384_inc_finalize(cmt_1[i], &state, cmt_1_i_input, sizeof(cmt_1_i_input));
            #elif (HASH_DIGEST_LENGTH*8 == 512)
               // sha512ctx state;
                sha512_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 64) + sizeof(cmt_1_i_input);
                sha512_inc_finalize_new(cmt_1[i], &state, cmt_1_i_input, sizeof(cmt_1_i_input), bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                //sha512_inc_finalize(cmt_1[i], &state, cmt_1_i_input, sizeof(cmt_1_i_input));
            #else
                #error digest length unsupported by SHA-2
            #endif
            //hash(cmt_1[i], cmt_1_i_input, sizeof(cmt_1_i_input));
        #endif    
    }

    /* vector containing d_0 and d_1 from spec */
    //uint8_t commit_digests[2][HASH_DIGEST_LENGTH];
   // uint8_t merkle_tree_0[NUM_NODES_OF_MERKLE_TREE * HASH_DIGEST_LENGTH];
    node_ctr = 0;
    parent_layer = LOGT-1;
    uint8_t trial[HASH_DIGEST_LENGTH];

    for (i_new=NUM_NODES_OF_MERKLE_TREE-1; i_new>0; i_new -= 2) {
       //hash(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), 
       //merkle_tree_0_new + OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH);
        #if defined (SHA3_HASH)
            m_new = merkle_tree_0_new+OFFSET(SIBLING(i_new));
            dlen = 2*HASH_DIGEST_LENGTH;
            hash_new(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), s,
            merkle_tree_0_new + OFFSET(SIBLING(i_new)), &dlen, m_new, r, 1);
            
            /*for (int i = 0; i < HASH_DIGEST_LENGTH; i++) {
                if((merkle_tree_0 + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]))[i]!=
                (merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]))[i])
                    printf("Error at %d %ld\n",i, i_new);
            }*/
            for (int i = 0; i < 25; ++i) {
                s[i] = 0;
            }
        #elif defined (SHA2_HASH)
            #if (HASH_DIGEST_LENGTH*8 == 256)
                //sha256ctx state;
                sha256_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 32) + 2*HASH_DIGEST_LENGTH;
                sha256_inc_finalize_new(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), 
                &state, merkle_tree_0_new+OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH, bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
               // sha256_inc_finalize(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), &state, 
                //merkle_tree_0_new+OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH);
                //sha256(digest,m, mlen);
            #elif (HASH_DIGEST_LENGTH*8 == 384)
               // sha384ctx state;
                sha384_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 32) + 2*HASH_DIGEST_LENGTH;
                sha384_inc_finalize_new(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]),
                &state, merkle_tree_0_new+OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH, bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif
                for (int i = 0; i < 48; ++i) {
                    (merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]))[i] = state.ctx[i];
                }
                //sha384_inc_finalize(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), &state, 
                //merkle_tree_0_new+OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH);
                //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
            #elif (HASH_DIGEST_LENGTH*8 == 512)
               // sha512ctx state;
                sha512_inc_init(&state);
                #ifdef PROFILE_HASHING
                    t0 = hal_get_time();
                #endif
                bytes = load_bigendian_64(state.ctx + 64) + 2*HASH_DIGEST_LENGTH;
                sha512_inc_finalize_new(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]),
                 &state, merkle_tree_0_new+OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH, bytes, 1);
                #ifdef PROFILE_HASHING
                    t1 = hal_get_time();
                    hash_cycles += (t1-t0);
                #endif

                //sha512_inc_finalize(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), &state, 
                //merkle_tree_0_new+OFFSET(SIBLING(i_new)), 2*HASH_DIGEST_LENGTH);
            #else
                #error digest length unsupported by SHA-2
            #endif
            //hash(merkle_tree_0_new + OFFSET(PARENT(i_new) + layer_offsets[parent_layer]), merkle_tree_0_new+OFFSET(SIBLING(i_new)),
            //2*HASH_DIGEST_LENGTH);
        #endif        
        if (node_ctr >= nodes_per_layer[parent_layer+1] - 2) {
            parent_layer--;
            node_ctr = 0;
        } else {
                node_ctr += 2;
        }
    }
    memcpy(commit_digests[0], merkle_tree_0_new, HASH_DIGEST_LENGTH);
    //merkle_tree_root_compute(commit_digests[0], merkle_tree_0, cmt_0);
    //hash(commit_digests[1], (unsigned char*)cmt_1, sizeof(cmt_1));
    /*#if defined (SHA3_HASH)
        m_new = (unsigned char*)cmt_1;
        dlen = sizeof(cmt_1);
        hash_new(commit_digests[1], s, (unsigned char*)cmt_1, &dlen, m_new, r, 1);
        for (int i = 0; i < 25; ++i) {
            s[i] = 0;
        }
    #elif defined (SHA2_HASH)
    #endif*/
    //hash(sig->digest_01, (unsigned char*) commit_digests, sizeof(commit_digests));
    #if defined (SHA3_HASH)
        m_new = commit_digests;
        dlen = sizeof(commit_digests);
        hash_new(sig->digest_01, s, (unsigned char*) commit_digests, &dlen, m_new, r, 1);
        for (int i = 0; i < 25; ++i) {
            s[i] = 0;
        }
    #elif defined (SHA2_HASH)
        #if (HASH_DIGEST_LENGTH*8 == 256)
            //sha256ctx state;
            sha256_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + sizeof(cmt_1);
            sha256_inc_finalize_new(commit_digests[1], &state, (unsigned char*)cmt_1, sizeof(cmt_1), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha256_inc_finalize(commit_digests[1], &state, (unsigned char*)cmt_1, sizeof(cmt_1));
            sha256_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + sizeof(commit_digests);
            sha256_inc_finalize_new(sig->digest_01, &state, (unsigned char*)commit_digests, sizeof(commit_digests), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha256_inc_finalize(sig->digest_01, &state, (unsigned char*)commit_digests, sizeof(commit_digests));
            //sha256(digest,m, mlen);
        #elif (HASH_DIGEST_LENGTH*8 == 384)
            // sha384ctx state;
            sha384_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + sizeof(cmt_1);
            sha384_inc_finalize_new(commit_digests[1], &state, (unsigned char*)cmt_1, sizeof(cmt_1), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            for (int i = 0; i < 48; ++i) {
                commit_digests[1][i] = state.ctx[i];
            }
            //sha384_inc_finalize(commit_digests[1], &state, (unsigned char*)cmt_1, sizeof(cmt_1));
            sha384_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + sizeof(commit_digests);
            sha384_inc_finalize_new(sig->digest_01, &state, (unsigned char*)commit_digests, sizeof(commit_digests), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            for (int i = 0; i < 48; ++i) {
                sig->digest_01[i] = state.ctx[i];
            }
            //sha384_inc_finalize(sig->digest_01, &state, (unsigned char*)commit_digests, sizeof(commit_digests));
            //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #elif (HASH_DIGEST_LENGTH*8 == 512)
            // sha512ctx state;
            sha512_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 64) + sizeof(cmt_1);
            sha512_inc_finalize_new(commit_digests[1], &state, (unsigned char*)cmt_1, sizeof(cmt_1), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha512_inc_finalize(commit_digests[1], &state, (unsigned char*)cmt_1, sizeof(cmt_1));
            
            sha512_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 64) + sizeof(commit_digests);
            sha512_inc_finalize_new(sig->digest_01, &state, (unsigned char*)commit_digests, sizeof(commit_digests), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha512_inc_finalize(sig->digest_01, &state, (unsigned char*)commit_digests, sizeof(commit_digests));
            //sha512(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #else
            #error digest length unsupported by SHA-2
        #endif
        //hash(commit_digests[1], (unsigned char*)cmt_1, sizeof(cmt_1));
        //hash(sig->digest_01, (unsigned char*)commit_digests, sizeof(commit_digests));
    #endif    
    /* first challenge extraction */
    uint8_t beta_buf[2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES];
    /* place d_m at the beginning of the input of the hash generating d_beta*/
    //hash(beta_buf,(uint8_t*) m,mlen);
    #if defined (SHA3_HASH)
        m_new = m;
        dlen = mlen;
        hash_new(beta_buf, s, (uint8_t*) m, &dlen, m_new, r, 1);
        for (int i = 0; i < 25; ++i) {
            s[i] = 0;
        }
    #elif defined (SHA2_HASH)
        #if (HASH_DIGEST_LENGTH*8 == 256)
            //sha256ctx state;
            sha256_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + mlen;
            sha256_inc_finalize_new(beta_buf, &state, (unsigned char*)m, mlen, bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha256_inc_finalize(beta_buf, &state, (uint8_t*)m, mlen);
            //sha256(digest,m, mlen);
        #elif (HASH_DIGEST_LENGTH*8 == 384)
            // sha384ctx state;
            sha384_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + mlen;
            sha384_inc_finalize_new(beta_buf, &state, (uint8_t*)m, mlen, bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            for (int i = 0; i < 48; ++i) {
                beta_buf[i] = state.ctx[i];
            }

            //sha384_inc_finalize(beta_buf, &state, (uint8_t*)m, mlen);
            //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #elif (HASH_DIGEST_LENGTH*8 == 512)
            // sha512ctx state;
            sha512_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 64) + mlen;
            sha512_inc_finalize_new(beta_buf, &state, (uint8_t*)m, mlen, bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif

            //sha512_inc_finalize(beta_buf, &state, (uint8_t*)m, mlen);
            //sha512(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #else
            #error digest length unsupported by SHA-2
        #endif    
        //hash(beta_buf, (uint8_t*)m, mlen);
    #endif    
    
    memcpy(beta_buf+HASH_DIGEST_LENGTH, sig->digest_01, HASH_DIGEST_LENGTH);
    memcpy(beta_buf+2*HASH_DIGEST_LENGTH, sig->salt, SALT_LENGTH_BYTES);

    uint8_t d_beta[HASH_DIGEST_LENGTH];
    //hash(d_beta,beta_buf,2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES);
    #if defined (SHA3_HASH)
        m_new = beta_buf;
        dlen = 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES;
        hash_new(d_beta, s, beta_buf, &dlen, m_new, r, 1);
        for (int i = 0; i < 25; ++i) {
            s[i] = 0;
        }
    #elif defined (SHA2_HASH)
        #if (HASH_DIGEST_LENGTH*8 == 256)
            //sha256ctx state;
            sha256_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES;
            sha256_inc_finalize_new(d_beta, &state, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES, bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha256_inc_finalize(d_beta, &state, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES);
            //sha256(digest,m, mlen);
        #elif (HASH_DIGEST_LENGTH*8 == 384)
            // sha384ctx state;
            sha384_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES;
            sha384_inc_finalize_new(d_beta, &state, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES, bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            for (int i = 0; i < 48; ++i) {
                d_beta[i] = state.ctx[i];
            }
            sha384_inc_finalize(d_beta, &state, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES);
            //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #elif (HASH_DIGEST_LENGTH*8 == 512)
            // sha512ctx state;
            sha512_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 64) + 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES;
            sha512_inc_finalize_new(d_beta, &state, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES, bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            //sha512_inc_finalize(d_beta, &state, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES);
            //sha512(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #else
            #error digest length unsupported by SHA-2
        #endif    
        //hash(d_beta, beta_buf, 2*HASH_DIGEST_LENGTH+SALT_LENGTH_BYTES);
    #endif    

    FQ_ELEM beta[T];
    initialize_csprng(&CSPRNG_state,d_beta,HASH_DIGEST_LENGTH);
    CSPRNG_fq_vec_beta(beta, &CSPRNG_state);

    /* Computation of the first round of responses */
    //FQ_ELEM y[T][N];
    #if defined (SHA3_HASH)
        uint8_t digest_b_buf[N*sizeof(FQ_ELEM)+r];   
        dlen = 0; 
    #elif defined (SHA2_HASH)
        uint8_t digest_b_buf[T*N*sizeof(FQ_ELEM)+HASH_DIGEST_LENGTH];
    #endif
    for(int i = 0; i < T; i++){
        fq_vec_by_restr_vec_scaled(u_tilde[i],
                                   eta_tilde[i],
                                   beta[i],
                                   u_tilde[i]);
        fq_dz_norm(u_tilde[i]);

        #if defined (SHA3_HASH)
            memcpy(digest_b_buf+dlen, u_tilde[i], N*sizeof(FQ_ELEM));    
            m_new = digest_b_buf;
            dlen += N*sizeof(FQ_ELEM);
            if(dlen> r)
                hash_new(sig->digest_b, s, digest_b_buf, &dlen, m_new, r, 0);
            if(i==T-1){
                memcpy(digest_b_buf+dlen, d_beta, HASH_DIGEST_LENGTH);
                dlen+=HASH_DIGEST_LENGTH;
                m_new = digest_b_buf;
                hash_new(sig->digest_b, s, digest_b_buf, &dlen, m_new, r, 1);
                for (i_new = 0; i_new < 25; ++i_new) {
                    s[i_new] = 0;
                }    
            }
    #elif defined (SHA2_HASH)
    #endif    

        /*fq_vec_by_restr_vec_scaled(y[i],
                                   eta_tilde[i],
                                   beta[i],
                                   u_tilde[i]);
        fq_dz_norm(y[i]);*/
    }

    /* Second challenge extraction */
    #if defined (SHA2_HASH)
  //  uint8_t digest_b_buf[T*N*sizeof(FQ_ELEM)+HASH_DIGEST_LENGTH];
    //memcpy(digest_b_buf,y,T*N*sizeof(FQ_ELEM));
        memcpy(digest_b_buf,u_tilde,T*N*sizeof(FQ_ELEM));
        memcpy(digest_b_buf+T*N*sizeof(FQ_ELEM),d_beta,HASH_DIGEST_LENGTH);
        #if (HASH_DIGEST_LENGTH*8 == 256)
            //sha256ctx state;
            sha256_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + sizeof(digest_b_buf);
            sha256_inc_finalize_new(sig->digest_b, &state, digest_b_buf, sizeof(digest_b_buf), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif

            //sha256_inc_finalize(sig->digest_b, &state, digest_b_buf, sizeof(digest_b_buf));
            //sha256(digest,m, mlen);
        #elif (HASH_DIGEST_LENGTH*8 == 384)
            // sha384ctx state;
            sha384_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 32) + sizeof(digest_b_buf);
            sha384_inc_finalize_new(sig->digest_b, &state, digest_b_buf, sizeof(digest_b_buf), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif
            for (int i = 0; i < 48; ++i) {
                sig->digest_b[i] = state.ctx[i];
            }
            //sha384_inc_finalize(sig->digest_b, &state, digest_b_buf, sizeof(digest_b_buf));
            //sha384(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #elif (HASH_DIGEST_LENGTH*8 == 512)
            // sha512ctx state;
            sha512_inc_init(&state);
            #ifdef PROFILE_HASHING
                t0 = hal_get_time();
            #endif
            bytes = load_bigendian_64(state.ctx + 64) + sizeof(digest_b_buf);
            sha512_inc_finalize_new(sig->digest_b, &state, digest_b_buf, sizeof(digest_b_buf), bytes, 1);
            #ifdef PROFILE_HASHING
                t1 = hal_get_time();
                hash_cycles += (t1-t0);
            #endif

            //sha512_inc_finalize(sig->digest_b, &state, digest_b_buf, sizeof(digest_b_buf));
            //sha512(cmt_0_new, cmt_0_i_input, sizeof(cmt_0_i_input));
        #else
            #error digest length unsupported by SHA-2
        #endif
        //hash(sig->digest_b, digest_b_buf, sizeof(digest_b_buf));
    #endif
    /*#if defined (SHA3_HASH)
        m_new = digest_b_buf;
        dlen = sizeof(digest_b_buf);
        hash_new(sig->digest_b, s, digest_b_buf, &dlen, m_new, r, 1);
        for (int i = 0; i < 25; ++i) {
            s[i] = 0;
        }
    #elif defined (SHA2_HASH)
    #endif*/    

    uint8_t fixed_weight_b[T]={0};
    /*since w > t-w, we generate a weight t-w string and flip the contents  */
    expand_digest_to_fixed_weight(fixed_weight_b,sig->digest_b);
    for(int i = 0; i<T; i++){
        fixed_weight_b[i] = !fixed_weight_b[i];
    }

    /* Computation of the second round of responses */
    uint16_t mtp_len;
    merkle_tree_proof_compute_new(sig->mtp,&mtp_len,merkle_tree_0_new,fixed_weight_b);
    publish_seeds(sig->stp,seed_tree,fixed_weight_b);

    int published_rsps = 0;
    for(int i = 0; i<T; i++){
        if(fixed_weight_b[i] == 0){
            assert(published_rsps < T-W);
           // pack_fq_vec(sig->rsp_0[published_rsps].y, y[i]);
            pack_fq_vec(sig->rsp_0[published_rsps].y, u_tilde[i]);
#if defined(RSDP)
            restr_vec_sub(sigma_new, eta,eta_tilde[i]);
            fz_dz_norm_sigma(sigma_new);
            pack_fz_vec(sig->rsp_0[published_rsps].sigma, sigma_new);
          //  pack_fz_vec(sig->rsp_0[published_rsps].sigma, sigma[i]);
#elif defined(RSDPG)
            pack_fz_rsdp_g_vec(sig->rsp_0[published_rsps].delta, delta[i]);
#endif
            memcpy(cmt_1_i_input+SEED_LENGTH_BYTES, sig->salt, SALT_LENGTH_BYTES);
            memcpy(cmt_1_i_input,
            seed_tree_leaves+SEED_LENGTH_BYTES*i,
                SEED_LENGTH_BYTES);
            cmt_1_i_input[SEED_LENGTH_BYTES+SALT_LENGTH_BYTES] = (i >> 8) &0xFF;
            cmt_1_i_input[SEED_LENGTH_BYTES+SALT_LENGTH_BYTES+1] = i & 0xFF;

            #if defined (SHA3_HASH)
                m_new = cmt_1_i_input;
                dlen = sizeof(cmt_1_i_input);
                for (i_new = 0; i_new < 25; ++i_new) {
                    s[i_new] = 0;
                }
                hash_new(cmt_1_new, s, cmt_1_i_input, &dlen, m_new, r, 1); 
                memcpy(sig->rsp_1[published_rsps], cmt_1_new, HASH_DIGEST_LENGTH);
                published_rsps++;   
            #elif defined (SHA2_HASH)
                memcpy(sig->rsp_1[published_rsps], cmt_1[i], HASH_DIGEST_LENGTH);
                published_rsps++;  
            #endif
            
            //published_rsps++;
        }
    }
}
